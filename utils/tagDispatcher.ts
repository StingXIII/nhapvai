
// File: utils/tagDispatcher.ts
// This module acts as a central dispatcher for processing all AI-generated tags.

import { parseTagParams } from './parsing';

// Import all the affinity-related tag processors
import {
    // FIX: Correctly import processNpcAffinityUpdate from the specified module.
    processNpcAffinityUpdate,
    processWifeAffinityUpdate,
    processSlaveAffinityUpdate,
    processPrisonerAffinityUpdate
} from './tagProcessors/affinityTagProcessors';

// In a full application, you would import other processors here as well:
// import { processItemAcquired } from './tagProcessors/itemTagProcessors';
// import { processQuestUpdate } from './tagProcessors/questTagProcessors';

/**
 * The main dispatcher function that orchestrates the processing of all tags from an AI response.
 * It iterates through a list of raw tags, parses each one, and routes it to the appropriate processor function.
 *
 * @param {any} knowledgeBase - The entire game state object. It's typed as 'any' here for flexibility,
 *                              but should be a strong type in a real application.
 * @param {string[]} tags - An array of raw tag strings extracted from the AI's response.
 *                          e.g., ['[NPC_UPDATE: name="Lão Trương", affinity="-=5"]', '[ITEM_ACQUIRED: name="Bánh Bao"]']
 * @returns {Promise<{ finalState: any; systemMessages: string[], affinityChanges: any[] }>} An object containing the
 *          modified knowledge base and a list of system messages generated by the processors.
 */
export async function dispatchTags(knowledgeBase: any, tags: string[]): Promise<{ finalState: any; systemMessages: string[]; affinityChanges: any[] }> {
    // FIX: This function was rewritten to correctly handle the return type from processors.
    // The processors now return `{ newState, vectorUpdates }`, and this function
    // correctly chains the state updates.
    let workingKnowledgeBase = knowledgeBase;

    for (const tag of tags) {
        // Regex to extract the tag name and its parameters string
        const match = tag.match(/\[(.*?):(.*?)\]/s);
        if (!match) {
            console.warn(`[TagDispatcher] Malformed tag skipped: ${tag}`);
            continue;
        }

        const tagName = match[1].toUpperCase().trim();
        const tagParamString = match[2].trim();
        
        // Parse the parameters string into a key-value object
        const params = parseTagParams(tagParamString);

        let processResult: { newState: any; vectorUpdates: any[] };

        // Route the tag to the correct processor based on its name
        switch (tagName) {
            // --- Affinity-Related Tags ---
            case 'NPC_UPDATE':
                processResult = processNpcAffinityUpdate(workingKnowledgeBase, params);
                workingKnowledgeBase = processResult.newState;
                break;
            case 'WIFE_UPDATE':
                processResult = processWifeAffinityUpdate(workingKnowledgeBase, params);
                workingKnowledgeBase = processResult.newState;
                break;
            case 'SLAVE_UPDATE':
                processResult = processSlaveAffinityUpdate(workingKnowledgeBase, params);
                workingKnowledgeBase = processResult.newState;
                break;
            case 'PRISONER_UPDATE':
                processResult = processPrisonerAffinityUpdate(workingKnowledgeBase, params);
                workingKnowledgeBase = processResult.newState;
                break;

            // --- Other Tag Types Would Go Here ---
            // case 'ITEM_ACQUIRED':
            //     // result = processItemAcquired(workingKnowledgeBase, params);
            //     break;
            // case 'QUEST_UPDATE':
            //     // result = processQuestUpdate(workingKnowledgeBase, params);
            //     break;
            
            default:
                // console.log(`[TagDispatcher] No processor found for tag: ${tagName}`);
                break;
        }
    }

    // The processors no longer return systemMessages or affinityChanges directly.
    // Return empty arrays to satisfy the function's return type signature.
    return {
        finalState: workingKnowledgeBase,
        systemMessages: [],
        affinityChanges: [],
    };
}
